{
    "language":"Solidity",
    "sources":{
    "contracts/ConsumerRole.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Import the library 'Roles'\nimport \"./Roles.sol\";\n\n// Define a contract 'ConsumerRole' to manage this role - add, remove, check\ncontract ConsumerRole {\n using Roles for Roles.Role;\n\n // Define 2 events, one for Adding, and other for Removing\n event ConsumerAdded(address indexed account);\n event ConsumerRemoved(address indexed account);\n // Define a struct 'consumers' by inheriting from 'Roles' library, struct Role\n Roles.Role private consumers;\n\n // In the constructor make the address that deploys this contract the 1st consumer\n constructor() {\n _addConsumer(msg.sender);\n }\n\n // Define a modifier that checks to see if msg.sender has the appropriate role\n modifier onlyConsumer() {\n require(isConsumer(msg.sender), 'Not a registered consumer!');\n _;\n }\n\n // Define a function 'isConsumer' to check this role\n function isConsumer(address account) public view returns (bool) {\n return consumers.has(account);\n }\n\n // Define a function 'addConsumer' that adds this role\n function addConsumer(address account) public onlyConsumer {\n _addConsumer(account);\n }\n\n // Define a function 'renounceConsumer' to renounce this role\n function renounceConsumer() public {\n _removeConsumer(msg.sender);\n }\n\n // Define an internal function '_addConsumer' to add this role, called by 'addConsumer'\n function _addConsumer(address account) internal {\n consumers.add(account);\n emit ConsumerAdded(account);\n }\n\n // Define an internal function '_removeConsumer' to remove this role, called by 'removeConsumer'\n function _removeConsumer(address account) internal {\n consumers.remove(account);\n emit ConsumerRemoved(account);\n }\n}"
    },
    "contracts/DistributorRole.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Import the library 'Roles'\nimport \"./Roles.sol\";\n\n// Define a contract 'DistributorRole' to manage this role - add, remove, check\ncontract DistributorRole {\n using Roles for Roles.Role;\n\n // Define 2 events, one for Adding, and other for Removing\n event DistributorAdded(address indexed account);\n event DistributorRemoved(address indexed account);\n // Define a struct 'distributors' by inheriting from 'Roles' library, struct Role\n Roles.Role private distributors;\n\n // In the constructor make the address that deploys this contract the 1st distributor\n constructor() {\n _addDistributor(msg.sender);\n }\n\n // Define a modifier that checks to see if msg.sender has the appropriate role\n modifier onlyDistributor() {\n require(isDistributor(msg.sender), 'Not a registered distributor!');\n _;\n }\n\n // Define a function 'isDistributor' to check this role\n function isDistributor(address account) public view returns (bool) {\n return distributors.has(account);\n }\n\n // Define a function 'addDistributor' that adds this role\n function addDistributor(address account) public onlyDistributor {\n _addDistributor(account);\n }\n\n // Define a function 'renounceDistributor' to renounce this role\n function renounceDistributor() public {\n _removeDistributor(msg.sender);\n }\n\n // Define an internal function '_addDistributor' to add this role, called by 'addDistributor'\n function _addDistributor(address account) internal {\n distributors.add(account);\n emit DistributorAdded(account);\n }\n\n // Define an internal function '_removeDistributor' to remove this role, called by 'removeDistributor'\n function _removeDistributor(address account) internal {\n distributors.remove(account);\n emit DistributorRemoved(account);\n }\n}"
    },
    "contracts/FarmerRole.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Import the library 'Roles'\nimport \"./Roles.sol\";\n\n// Define a contract 'FarmerRole' to manage this role - add, remove, check\ncontract FarmerRole {\n using Roles for Roles.Role;\n\n // Define 2 events, one for Adding, and other for Removing\n event FarmerAdded(address indexed account);\n event FarmerRemoved(address indexed account);\n\n // Define a struct 'farmers' by inheriting from 'Roles' library, struct Role\n Roles.Role private farmers;\n\n // In the constructor make the address that deploys this contract the 1st farmer\n constructor() {\n _addFarmer(msg.sender);\n }\n\n // Define a modifier that checks to see if msg.sender has the appropriate role\n modifier onlyFarmer() {\n require(isFarmer(msg.sender), 'Not a registered farmer!');\n _;\n }\n\n // Define a function 'isFarmer' to check this role\n function isFarmer(address account) public view returns (bool) {\n return farmers.has(account);\n }\n\n // Define a function 'addFarmer' that adds this role\n function addFarmer(address account) public onlyFarmer {\n _addFarmer(account);\n }\n\n // Define a function 'renounceFarmer' to renounce this role\n function renounceFarmer() public {\n _removeFarmer(msg.sender);\n }\n\n // Define an internal function '_addFarmer' to add this role, called by 'addFarmer'\n function _addFarmer(address account) internal {\n farmers.add(account);\n emit FarmerAdded(account);\n }\n\n // Define an internal function '_removeFarmer' to remove this role, called by 'removeFarmer'\n function _removeFarmer(address account) internal {\n farmers.remove(account);\n emit FarmerRemoved(account);\n }\n}"
    },
    "contracts/RetailerRole.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Import the library 'Roles'\nimport \"./Roles.sol\";\n\n// Define a contract 'RetailerRole' to manage this role - add, remove, check\ncontract RetailerRole {\n using Roles for Roles.Role;\n\n // Define 2 events, one for Adding, and other for Removing\n event RetailerAdded(address indexed account);\n event RetailerRemoved(address indexed account);\n // Define a struct 'retailers' by inheriting from 'Roles' library, struct Role\n Roles.Role private retailers;\n\n // In the constructor make the address that deploys this contract the 1st retailer\n constructor() {\n _addRetailer(msg.sender);\n }\n\n // Define a modifier that checks to see if msg.sender has the appropriate role\n modifier onlyRetailer() {\n require(isRetailer(msg.sender), 'Not a registered retailer!');\n _;\n }\n\n // Define a function 'isRetailer' to check this role\n function isRetailer(address account) public view returns (bool) {\n return retailers.has(account);\n }\n\n // Define a function 'addRetailer' that adds this role\n function addRetailer(address account) public onlyRetailer {\n _addRetailer(account);\n }\n\n // Define a function 'renounceRetailer' to renounce this role\n function renounceRetailer() public {\n _removeRetailer(msg.sender);\n }\n\n // Define an internal function '_addRetailer' to add this role, called by 'addRetailer'\n function _addRetailer(address account) internal {\n retailers.add(account);\n emit RetailerAdded(account);\n }\n\n // Define an internal function '_removeRetailer' to remove this role, called by 'removeRetailer'\n function _removeRetailer(address account) internal {\n retailers.remove(account);\n emit RetailerRemoved(account);\n }\n}"
    },
    "contracts/Roles.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n struct Role {\n mapping (address => bool) bearer;\n }\n\n /**\n * @dev give an account access to this role\n */\n function add(Role storage role, address account) internal {\n require(account != address(0), 'You cannot work with a null/burner address!');\n require(!has(role, account), 'This address already has a role!');\n\n role.bearer[account] = true;\n }\n\n /**\n * @dev remove an account's access to this role\n */\n function remove(Role storage role, address account) internal {\n require(account != address(0), 'You cannot work with a null/burner address!');\n require(has(role, account), 'This address does not have a role yet!');\n\n role.bearer[account] = false;\n }\n\n /**\n * @dev check if an account has this role\n * @return bool\n */\n function has(Role storage role, address account)\n internal\n view\n returns (bool)\n {\n require(account != address(0), 'You cannot work with a null/burner address!');\n return role.bearer[account];\n }\n}"
    },
    "contracts/SupplyChain.sol":{
    "content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./ConsumerRole.sol\";\nimport \"./DistributorRole.sol\";\nimport \"./FarmerRole.sol\";\nimport \"./RetailerRole.sol\";\n\n\n// Define a contract 'Supplychain'\ncontract SupplyChain is ConsumerRole, RetailerRole, DistributorRole, FarmerRole {\n\n // Define 'owner'\n address public owner;\n\n // Define a variable called 'upc' for Universal Product Code (UPC)\n uint upc;\n\n // Define a variable called 'sku' for Stock Keeping Unit (SKU)\n uint sku;\n\n // Define a public mapping 'items' that maps the UPC to an Item.\n mapping (uint => Item) items;\n\n // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, \n // that track its journey through the supply chain -- to be sent from DApp.\n mapping (uint => string[]) itemsHistory;\n \n // Define enum 'State' with the following values:\n enum State \n { \n Harvested, // 0\n Processed, // 1\n Packed, // 2\n ForSale, // 3\n Sold, // 4\n Shipped, // 5\n Received, // 6\n Purchased // 7\n }\n\n State constant defaultState = State.Harvested;\n\n // Define a struct 'Item' with the following fields:\n struct Item {\n uint sku; // Stock Keeping Unit (SKU)\n uint upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer\n address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages\n address originFarmerID; // Metamask-Ethereum address of the Farmer\n string originFarmName; // Farmer Name\n string originFarmInformation; // Farmer Information\n string originFarmLatitude; // Farm Latitude\n string originFarmLongitude; // Farm Longitude\n uint productID; // Product ID potentially a combination of upc + sku\n string productNotes; // Product Notes\n uint productPrice; // Product Price\n State itemState; // Product State as represented in the enum above\n address distributorID; // Metamask-Ethereum address of the Distributor\n address retailerID; // Metamask-Ethereum address of the Retailer\n address consumerID; // Metamask-Ethereum address of the Consumer\n }\n\n // Define 8 events with the same 8 state values and accept 'upc' as input argument\n event Harvested(uint upc);\n event Processed(uint upc);\n event Packed(uint upc);\n event ForSale(uint upc);\n event Sold(uint upc);\n event Shipped(uint upc);\n event Received(uint upc);\n event Purchased(uint upc);\n\n // Define a modifer that checks to see if msg.sender == owner of the contract\n modifier onlyOwner() {\n require(msg.sender == owner, 'The Caller is not the owner!');\n _;\n }\n\n // Define a modifer that verifies the Caller\n modifier verifyCaller (address _address) {\n require(msg.sender == _address, 'Caller verification failed!'); \n _;\n }\n\n // Define a modifier that checks if the paid amount is sufficient to cover the price\n modifier paidEnough(uint _price) { \n require(msg.value >= _price, 'The paid amount is not sufficient!'); \n _;\n }\n \n // Define a modifier that checks the price and refunds the remaining balance\n modifier checkValue(uint _upc) {\n _;\n uint _price = items[_upc].productPrice;\n uint amountToReturn = msg.value - _price;\n payable(items[_upc].consumerID).transfer(amountToReturn);\n }\n\n // Define a modifier that checks if an item.state of a upc is Harvested\n modifier harvested(uint _upc) {\n require(items[_upc].itemState == State.Harvested, 'The current state of the item is not harvested yet!');\n _;\n }\n\n // Define a modifier that checks if an item.state of a upc is Processed\n modifier processed(uint _upc) {\n require(items[_upc].itemState == State.Processed, 'The current state of the item is not procrssed yet!');\n _;\n }\n \n // Define a modifier that checks if an item.state of a upc is Packed\n modifier packed(uint _upc) {\n require(items[_upc].itemState == State.Packed, 'The current state of the item is not packed yet!');\n _;\n }\n\n // Define a modifier that checks if an item.state of a upc is ForSale\n modifier forSale(uint _upc) {\n require(items[_upc].itemState == State.ForSale, 'The current state of the item is not for sale yet!');\n _;\n }\n\n // Define a modifier that checks if an item.state of a upc is Sold\n modifier sold(uint _upc) {\n require(items[_upc].itemState == State.Sold, 'The current state of the item is not sold yet!');\n _;\n }\n \n // Define a modifier that checks if an item.state of a upc is Shipped\n modifier shipped(uint _upc) {\n require(items[_upc].itemState == State.Shipped, 'The current state of the item is not shipped yet!');\n _;\n }\n\n // Define a modifier that checks if an item.state of a upc is Received\n modifier received(uint _upc) {\n require(items[_upc].itemState == State.Received, 'The current state of the item is not received yet!');\n _;\n }\n\n // Define a modifier that checks if an item.state of a upc is Purchased\n modifier purchased(uint _upc) {\n require(items[_upc].itemState == State.Purchased, 'The current state of the item is not purchased yet!');\n _;\n }\n\n // In the constructor set 'owner' to the address that instantiated the contract\n // and set 'sku' to 1\n // and set 'upc' to 1\n constructor() payable {\n owner = msg.sender;\n sku = 1;\n upc = 1;\n }\n\n // Define a function 'kill' if required\n function kill() public {\n if (msg.sender == owner) {\n selfdestruct(payable(owner));\n }\n }\n\n // Define a function 'harvestItem' that allows a farmer to mark an item 'Harvested'\n function harvestItem(uint _upc, address _originFarmerID, string calldata _originFarmName, string calldata _originFarmInformation, string calldata _originFarmLatitude, string calldata _originFarmLongitude, string calldata _productNotes) public \n {\n // Add the new item as part of Harvest\n items[_upc].sku = sku;\n items[_upc].upc = _upc;\n items[_upc].ownerID = _originFarmerID;\n items[_upc].originFarmerID = _originFarmerID;\n items[_upc].originFarmName = _originFarmName;\n items[_upc].originFarmInformation = _originFarmInformation;\n items[_upc].originFarmLatitude = _originFarmLatitude;\n items[_upc].originFarmLongitude = _originFarmLongitude;\n items[_upc].productID = _upc + sku;\n items[_upc].productNotes = _productNotes;\n\n // Increment sku\n sku = sku + 1;\n // Emit the appropriate event\n emit Harvested(_upc);\n }\n\n // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'\n function processItem(uint _upc) public \n // Call modifier to check if upc has passed previous supply chain stage\n harvested(_upc)\n // Call modifier to verify caller of this function\n verifyCaller(items[_upc].originFarmerID)\n {\n // Update the appropriate fields\n items[_upc].itemState = State.Processed;\n // Emit the appropriate event\n emit Processed(_upc);\n }\n\n // Define a function 'packItem' that allows a farmer to mark an item 'Packed'\n function packItem(uint _upc) public \n // Call modifier to check if upc has passed previous supply chain stage\n processed(_upc)\n // Call modifier to verify caller of this function\n verifyCaller(items[_upc].originFarmerID)\n {\n // Update the appropriate fields\n items[_upc].itemState = State.Packed;\n // Emit the appropriate event\n emit Packed(_upc);\n }\n\n // Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'\n function sellItem(uint _upc, uint _price) public \n // Call modifier to check if upc has passed previous supply chain stage\n packed(_upc)\n // Call modifier to verify caller of this function\n verifyCaller(items[_upc].originFarmerID)\n {\n // Update the appropriate fields\n items[_upc].itemState = State.ForSale;\n items[_upc].productPrice = _price;\n // Emit the appropriate event\n emit ForSale(_upc);\n }\n\n // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'\n // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, \n // and any excess ether sent is refunded back to the buyer\n function buyItem(uint _upc) public payable \n // Call modifier to check if upc has passed previous supply chain stage\n forSale(_upc)\n // Call modifer to check if buyer has paid enough\n paidEnough(msg.value)\n // Call modifer to send any excess ether back to buyer\n checkValue(_upc)\n {\n \n // Update the appropriate fields - ownerID, distributorID, itemState\n items[_upc].ownerID = msg.sender;\n items[_upc].distributorID = msg.sender;\n items[_upc].itemState = State.Sold;\n // Transfer money to farmer\n payable(items[_upc].originFarmerID).transfer(items[_upc].productPrice);\n // emit the appropriate event\n emit Sold(_upc);\n }\n\n // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'\n // Use the above modifers to check if the item is sold\n function shipItem(uint _upc) public \n // Call modifier to check if upc has passed previous supply chain stage\n sold(_upc)\n // Call modifier to verify caller of this function\n verifyCaller(items[_upc].distributorID)\n {\n // Update the appropriate fields\n items[_upc].itemState = State.Shipped;\n // Emit the appropriate event\n emit Shipped(_upc);\n }\n\n // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'\n // Use the above modifiers to check if the item is shipped\n function receiveItem(uint _upc) public \n // Call modifier to check if upc has passed previous supply chain stage\n shipped(_upc)\n // Access Control List enforced by calling Smart Contract / DApp\n onlyRetailer() \n {\n // Update the appropriate fields - ownerID, retailerID, itemState\n items[_upc].ownerID = msg.sender;\n items[_upc].retailerID = msg.sender;\n items[_upc].itemState = State.Received;\n // Emit the appropriate event\n emit Received(_upc);\n }\n\n // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'\n // Use the above modifiers to check if the item is received\n function purchaseItem(uint _upc) public \n // Call modifier to check if upc has passed previous supply chain stage\n received(_upc)\n // Access Control List enforced by calling Smart Contract / DApp\n onlyConsumer()\n {\n // Update the appropriate fields - ownerID, consumerID, itemState\n items[_upc].ownerID = msg.sender;\n items[_upc].consumerID = msg.sender;\n items[_upc].itemState = State.Purchased;\n // Emit the appropriate event\n emit Purchased(_upc);\n }\n\n // Define a function 'fetchItemBufferOne' that fetches the data\n function fetchItemBufferOne(uint _upc) public view returns \n (\n uint itemSKU,\n uint itemUPC,\n address ownerID,\n address originFarmerID,\n string memory originFarmName,\n string memory originFarmInformation,\n string memory originFarmLatitude,\n string memory originFarmLongitude\n ) \n {\n // Assign values to the 8 parameters\n itemSKU = items[_upc].sku;\n itemUPC = items[_upc].upc;\n ownerID = items[_upc].ownerID;\n originFarmerID = items[_upc].originFarmerID;\n originFarmName = items[_upc].originFarmName;\n originFarmInformation = items[_upc].originFarmInformation;\n originFarmLatitude = items[_upc].originFarmLatitude;\n originFarmLongitude = items[_upc].originFarmLongitude;\n \n return \n (\n itemSKU,\n itemUPC,\n ownerID,\n originFarmerID,\n originFarmName,\n originFarmInformation,\n originFarmLatitude,\n originFarmLongitude\n );\n }\n\n // Define a function 'fetchItemBufferTwo' that fetches the data\n function fetchItemBufferTwo(uint _upc) public view returns \n (\n uint itemSKU,\n uint itemUPC,\n uint productID,\n string memory productNotes,\n uint productPrice,\n uint itemState,\n address distributorID,\n address retailerID,\n address consumerID\n ) \n {\n // Assign values to the 9 parameters\n itemSKU = items[_upc].sku;\n itemUPC = items[_upc].upc;\n productID = items[_upc].productID;\n productNotes = items[_upc].productNotes;\n productPrice = items[_upc].productPrice;\n itemState = uint(items[_upc].itemState);\n distributorID = items[_upc].distributorID;\n retailerID = items[_upc].retailerID;\n consumerID = items[_upc].consumerID;\n \n return \n (\n itemSKU,\n itemUPC,\n productID,\n productNotes,\n productPrice,\n itemState,\n distributorID,\n retailerID,\n consumerID\n );\n }\n}"
    }
    },
    "settings":{
    "optimizer":{
    "enabled":true,
    "runs":100
    },
    "viaIR":true,
    "outputSelection":{
    "*":{
    "*":[
    "abi",
    "evm.bytecode",
    "evm.deployedBytecode",
    "evm.methodIdentifiers",
    "metadata"
    ],
    "":[
    "ast"
    ]
    }
    }
    }
    }